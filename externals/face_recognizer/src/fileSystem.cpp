#include "fileSystem.hpp"

#include <fstream>
#include <sys/stat.h>

#include "macros.hpp"

namespace fs = std::experimental::filesystem::v1;
using namespace event;

FileSystem *FileSystem::m_instance = nullptr;
User FileSystem::m_currentUser;

const char *FileSystem::FRAMES_WRITE_PATH = "./facedata";
const char *FileSystem::FRAMES_BASE_FILENAME = "frameData_";
const char *FileSystem::FRAMES_EXTENSION = ".fr";

FileSystem::FileSystem()
{
    CreateUserMapping();
}

FileSystem &FileSystem::GetInstance()
{
    if (!m_instance)
    {
        m_instance = new FileSystem;
    }

    return *m_instance;
}

void FileSystem::CreateUserMapping()
{
    std::string dirname = FRAMES_WRITE_PATH;

    for (const auto &dirEntry : fs::recursive_directory_iterator(dirname.c_str()))
    {
        fs::path filePath = dirEntry.path();

        struct stat fileStat;
        if (stat(filePath.c_str(), &fileStat) == 0)
        {
            if (fileStat.st_mode & S_IFDIR)
            {
                std::string name = filePath.parent_path().filename().c_str();
                int label = HashString(name);

                m_userLabelMap[label] = name;
            }
        }
    }

    LOG_INFO("Created user mapping. Users found: %ld", m_userLabelMap.size());
}

void FileSystem::WriteFrames(const std::vector<FaceFrame> &frames) const
{
    User user = FileSystem::GetInstance().GetCurrentUser();

    if (!user._isValid)
    {
        std::string errorMessage = "Cannot save frames, because no valid user was specified!";
        LOG_ERROR("%s", errorMessage.c_str());
        NotifyObserversAbout(new EventErrorOccured(errorMessage));
        return;
    }

    size_t index = 0;

    for (const auto &frame : frames)
    {
        std::string filename = FRAMES_WRITE_PATH;
        filename += "/";
        filename += user.username;
        filename += "/";
        filename += FRAMES_BASE_FILENAME;
        filename += std::to_string(index++);
        filename += FRAMES_EXTENSION;

        std::ofstream outFile;
        outFile.open(filename.c_str());
        ASSERT(outFile.is_open(), "Cannot create file!");

        frame.Serialize(outFile);

        outFile.close();

        LOG_INFO("Saved frame file: %s", filename.c_str());
    }
}

std::vector<FaceFrame> FileSystem::LoadFrames() const
{
    std::string dirname = FRAMES_WRITE_PATH;
    std::vector<FaceFrame> frames;

    for (const auto &dirEntry : fs::recursive_directory_iterator(dirname.c_str()))
    {
        fs::path filePath = dirEntry.path();

        if (strcmp(filePath.extension().c_str(), FRAMES_EXTENSION) == 0)
        {
            std::ifstream inFile;
            inFile.open(filePath.c_str());

            FaceFrame frame;
            frame.Deserialize(inFile);
            frames.push_back(frame);

            inFile.close();
        }
    }

    return frames;
}

int FileSystem::HashString(const std::string &str) const
{
    // Assuming that the distribution of hashes generated by the function below
    // is close to random (indistinguishable from random), then we may
    // assume that when we trim those hashes to an int32 value by taking it's
    // first 32 bits, we do not loose that indistinguishability.

    size_t hash = std::hash<std::string>{}(str.c_str());
    // Trim to int:
    int intHash = (int)hash;

    return intHash;
}

int FileSystem::GetUserHash(const User &user) const
{
    return HashString(user.username);
}

User FileSystem::GetUserByHash(int label)
{
    User user;

    if (m_userLabelMap.find(label) != m_userLabelMap.end())
    {
        user.username = m_userLabelMap[label];
        user._isValid = true;
    }

    return user;
}

void FileSystem::SetCurrentUser(const User &user)
{
    m_currentUser = user;
}

const User &FileSystem::GetCurrentUser() const
{
    return m_currentUser;
}